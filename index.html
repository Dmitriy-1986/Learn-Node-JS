<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Изучаю Node.js</title>
  
  <link rel="stylesheet" href="./style.css">

  <link rel="shortcut icon" href="./img/logo-js.png" type="image/png">
</head>

<body>
  
  <h1>Изучаю Node.js</h1>
  
  <main>
    <h2><a href="https://github.com/Dmitriy-1986/Learn-Node-JS/blob/master/index.html">Изучаю Node.js</a></h2>
    <ol id="lists"></ol>
    <div id="paragraph"></div>
  </main>
  <footer>
    <span>2022 - Dovgal Dima - Изучаю Node.js</span>
  </footer>
  
  <script>
    const links = [
      { strLink: 'https://github.com/Dmitriy-1986/Learn-Node-JS/blob/master/hello.js', strName: 'Создание сервера Node.js' },
      { strLink: 'https://github.com/Dmitriy-1986/Learn-Node-JS/blob/master/sync-async.js', strName: 'Синхронный и асинхронный ввод/вывод в Node.js' },
      { strLink: 'https://github.com/Dmitriy-1986/Learn-Node-JS/blob/master/buffer.js', strName: 'Buffer в Node' },
      //{ strLink: '#', strName: 'No name link' },
      //{ strLink: '#', strName: 'No name link' },
      //{ strLink: '#', strName: 'No name link' },
      //{ strLink: '#', strName: 'No name link' },
      //{ strLink: '#', strName: 'No name link' },
      //{ strLink: '#', strName: 'No name link' },
    ];
    
    const text = [
      {txt: 'Среда Node обладает богатой функциональностью, и имеет широкое распространение, начать установку <a href="https://nodejs.org/">Node</a>'},
      {txt: 'Устанавливая Node  для Windows, необходимо подтвердить местонахождение и набор компонентов по умолчанию. Программа установки добавляет каталог Node в переменную PATH, чтобы команду node можно было вводить без указания полного пути установки Node.'},
      {txt: 'Сначала программа включает необходимый для запуска простого сервера HTTP модуль с подходящим именем  HTTP. Внешняя функциональность Node подключается при помощи модулей, экспортирующих определенные типы функциональности, которая может использоваться в приложении или другом модуле. Модули похожи на библиотеки в других языках программирования.'},
      {txt: '<pre><code><span class="variable">const</span> http = <span class="module">require</span>(<span class="param">\'http\'</span>); </code></pre>'},
      {txt: 'Модуль импортируется командой Node require, а результат присваивается локальной переменной. После импортирования локальная переменная может использоваться для создания экземпляра веб-сервера функцией http.createServer(), которая принимает в параметрах функцию обратного вызова (callback), которая передает веб-запрос и ответ коду, который обрабатывает веб-запрос и предоставляет ответ.'},
      {txt: 'После того как сервер был создан и получил запрос, функция обратного вызова передает браузеру простой тектовый заголовок с кодом статуса 200, и выводит содержимое, после чего завершает ответ. Всего в нескольких строках кода создается <a href="https://nodejs.org/ru/docs/guides/getting-started-guide/">веб-сервер в среде Node.js</a>'},
      {txt: 'Простой вывод статического сообщения, демонстрирует, что приложение работает и показывает как создать простой веб-сервер. Базовый пример также демонстрирует ключевые элементы всех приложений Node.'},
      {txt: 'Node.js поддерживает как синхронную, так и асинхронную версию большинства функций файловой системы. Обычно использование синхронных операций в веб-запросах в Node.js считается крайне нежелательным, но такая возможность существует'},
      {txt: 'С синхронныйми функциями можно использовать конструкцию try...catch. С асинхронными функциями эта обработка ошибок невозможна, отсюда и передача кода ошибки в параметрах функции.'},
      {txt: 'Чтобы получить информацию обо всех доступных параметрах, можно возпользоватся ключом -h или --help. С этим параметром команда node выводит список всех параметров и синтаксис запуска приложения Node.'},
      {txt: '<pre><code>$ node --help</code></pre>'},
      {txt: 'Для получения версии Node используется команда node -v или node --version'},
      {txt: '<pre><code>$ node --version</code></pre>'},
      {txt: 'Большая часть Node.js написана на С++, зная хорошо С или С++ можно расширить функциональность Node.js - для этого следует написать на С/С++ дополнение.'},
      {txt: '<h3>Структурные элементы Node: глобальные объекты.</h3>'},
      {txt: 'Объекты global и process два важнейших объекта в Node.js. Переменная обьявленная в модуле или приложении Node не обладает глобальной доступностью, она ограничиваеться модулем или приложением. Таким образом можно объявить глобальную переменную в модуле и в приложении, использующем этот модуль, и никакого конфликта не будет.'},
      {txt: 'Объект global во всех средах предоставляет доступ к глобально доступгым объектам и функциям Node, велючая объект process. Команда в консоли выводит все глобально досиупные объекты и функции.'},
      {txt: '<pre><code>console.log(global);</code></pre>'},
      {txt: 'Объект process принадлежит к числу важнейших компонентов среды Node, так как он предоставляет информацию о среде выполнения. Кроме того, через объект process выполняется стандартный ввод/вывод, можно корректно завершить приложение Node и даже выдать сигнал при завершении итерации в циклесобытий Node.js.'},
      {txt: 'C  помощью объекта  process можно получить информацию о среде выполнения объекта process, а также важные средства стандартного ввода/вывода. Ддля проверки свойства process.versions необходимо ввести команду.'},
      {txt: '<pre><code>$ node -p "process.versions"</code></pre>'},
      {txt: 'Информация о среде позволяет разработчику понять, что видит Node до и после разработки.'},
      {txt: '<h3>Буферы в Node</h3>'},
      {txt: 'В Node.js используется объект Buffer  для операций ввода/вывода данных при преобразовании типизированного массива'},
      {txt: 'Буфер Node содержит низкоуровневые двоичные данные. Для управления буфером используеться класс Buffer. После того как память будет выделена, изменить размер буфера не удастся.'},
      {txt: 'Буфер по умолчанию используеться для работы с файлами. Для создания буфера используется ключевое слово new. Заполнять буфер лучше после его создания для избежания неприятных сюрпризов.'},
      {txt: `<pre><code><span class="variable">let</span> buf = <span class="module">new Buffer</span>(<span class="param">24</span>); 
buf.<span class="module">fill</span>(<span class="param">0</span>); //Буфер заполняется нулями</code></pre>`},
      {txt: '<h3>Обратные вызовы и асинхронная обработка событий Node</h3>'},
      {txt: 'Язык JavaScript является однопоточным, то есть синхронным по своей природе. Это означает, что код JavaScript выполняется строка за строкой до тех пор, пока приложение не будет завершено. Так как среда Node базируется на JavaScript, она наследует это однопоточное синхронное поведение.'},
      {txt: 'Но если в приложении используется функциональность, требующая ожидания некоторого условия (например, открытия файла), получения веб - ответа, или другой аналогичной операции, блокирование приложения до завершения операции создаст серьезную критическую точку в серверном приложении.'},
      {txt: 'Для достижения асинхронной функциональности приложение может пойти по одному из двух путей. Первый вариант - выделить каждый продолжительный процесс в отдельный програмный поток. В это время остальной код выполняется параллельно. Недостаток многопоточного решения заключается в том, что потоки обходятся дорого. Они требуют значительных затрат ресурсов и сильно повышают сложность приложения.'},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
      //{txt: ''},
    ];

    for (let i = 0; i < links.length; i++) {
      let lists = document.getElementById('lists');
      lists.innerHTML += `<li><a href='${links[i].strLink}'>${links[i].strName}</a>
        <svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true">
          <path fill="#dcc6e0"
            d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z">
          </path>
        </svg></li>
      `;
    };
    
    for (let p = 0; p < text.length; p++) {
      let paragraph = document.getElementById('paragraph');
      paragraph.innerHTML += `<p>${text[p].txt}</p>`;
    };
  </script>
  
</body>

</html>
